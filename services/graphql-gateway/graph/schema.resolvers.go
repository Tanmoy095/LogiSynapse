package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"fmt"

	"github.com/Tanmoy095/LogiSynapse/graphql-gateway/graph/generated"
	"github.com/Tanmoy095/LogiSynapse/graphql-gateway/graph/model"
	"github.com/google/uuid"
)

// In-memory store for shipments, initialized with hardcoded data
var shipments = []*model.Shipment{
	{
		ID:          "1",
		Status:      model.ShipmentStatusInTransit, // Use enum value
		Origin:      "Dhaka",
		Destination: "Berlin",
		Eta:         "2025-07-15",
		Carrier: &model.Carrier{
			Name:        "DHL",
			TrackingURL: "https://dhl.com/track/123",
		},
	},
	{
		ID:          "2",
		Status:      model.ShipmentStatusDelivered, // Use enum value
		Origin:      "Chittagong",
		Destination: "Munich",
		Eta:         "2025-07-10",
		Carrier: &model.Carrier{
			Name:        "DHL",
			TrackingURL: "https://dhl.com/track/123",
		},
	},
}

// CreateShipment is the resolver for the createShipment field.
func (r *mutationResolver) CreateShipment(ctx context.Context, input model.NewShipmentInput) (*model.Shipment, error) {
	newID := uuid.New().String()

	newShipment := &model.Shipment{
		ID:          newID,
		Status:      input.Status, // Uses GraphQL enum (IN_TRANSIT, DELIVERED, PENDING)
		Origin:      input.Origin,
		Destination: input.Destination,
		Eta:         input.Eta,
		Carrier: &model.Carrier{
			Name:        input.Carrier.Name,
			TrackingURL: input.Carrier.TrackingURL, // Fixed to match schema (trackingUrl)
		},
	}
	shipments = append(shipments, newShipment)
	return newShipment, nil
}

// Now implement Query resolver methods on queryResolver
func (r *queryResolver) Shipments(ctx context.Context, origin *string, status *model.ShipmentStatus, destination *string, limit *int, offset *int) ([]*model.Shipment, error) {
	// Set default pagination values
	lim := 10
	if limit != nil {
		lim = *limit

	}
	off := 0
	if offset != nil {
		off = *offset

	}

	//start with all shipments..............
	filtered := shipments

	// Apply all Filter  if  any parameter provided

	if origin != nil || status != nil || destination != nil {
		var temp []*model.Shipment
		for _, shipment := range shipments {
			//check shipments matches all provided filters..
			matches := true
			if origin != nil && shipment.Origin != *origin {
				matches = false

			}
			if status != nil && shipment.Status != *status {
				matches = false
			}
			if destination != nil && shipment.Destination != *destination {
				matches = false
			}
			// Include shipment if it matches all filters
			if matches {
				temp = append(temp, shipment)
			}
		}

	} else {

		filtered = shipments // No filter, use all shipments
	}

	// Apply pagination
	// Ensure offset is valid (not negative or beyond the list length)
	if off < 0 || off > len(filtered) {
		return []*model.Shipment{}, nil //Return empty list for invalid offset
	}
	// Ensure limit is non-negative
	if lim < 0 {
		lim = 0
	}
	// Calculate the end index for slicing (offset + limit)
	end := lim + off
	if end > len(filtered) {
		end = len(filtered) // Donâ€™t exceed the list length

	}
	// Return the paginated slice (e.g., filtered[0:10] for first 10 items)
	return filtered[off:end], nil
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (string, error) {
	panic(fmt.Errorf("not implemented: Health - health"))
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
