package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76
import (
	"context"
	"fmt"

	"github.com/Tanmoy095/LogiSynapse/graphql-gateway/graph/generated"
	"github.com/Tanmoy095/LogiSynapse/graphql-gateway/internal/models"

	"github.com/Tanmoy095/LogiSynapse/graphql-gateway/graph/model" // Generated GraphQL models
)

// Mutation returns the MutationResolver implementation.
// Analogy: Defines the waiter's tasks for handling customer orders (mutations).
func (r *Resolver) Mutation() generated.MutationResolver {
	return &mutationResolver{r}
}

// Query returns the QueryResolver implementation.
// Analogy: Defines the waiter's tasks for handling customer queries.
func (r *Resolver) Query() generated.QueryResolver {
	return &queryResolver{r}
}

type mutationResolver struct{ *Resolver }

// CreateShipment handles the GraphQL mutation for creating a shipment.
// It converts the GraphQL input to a local model and calls the gRPC client.
// Analogy: Waiter sends a new dish order to the kitchen via intercom.
func (r *mutationResolver) CreateShipment(ctx context.Context, input model.NewShipmentInput) (*model.Shipment, error) {
	// Convert GraphQL input (model.NewShipmentInput) to local model (models.Shipment)
	shipment := models.Shipment{
		Origin:      input.Origin,
		Destination: input.Destination,
		Eta:         input.Eta,
		Status:      models.ShipmentStatus(input.Status), // Convert GraphQL enum to local enum
		Carrier: models.Carrier{
			Name:        input.Carrier.Name,
			TrackingURL: input.Carrier.TrackingURL,
		},
	}

	// Call the gRPC client to create the shipment
	// Analogy: Waiter sends the order to the kitchen via intercom
	created, err := r.shipmentClient.CreateShipment(ctx, shipment)
	if err != nil {
		return nil, err // Propagate errors (e.g., service unavailable)
	}

	// Convert response to GraphQL model
	result := &model.Shipment{
		ID:          created.ID,
		Origin:      created.Origin,
		Destination: created.Destination,
		Eta:         created.Eta,
		Status:      model.ShipmentStatus(created.Status), // Convert local enum to GraphQL enum
		Carrier: &model.Carrier{
			Name:        created.Carrier.Name,
			TrackingURL: created.Carrier.TrackingURL,
		},
	}
	// Analogy: Waiter serves the prepared dish to the customer
	return result, nil
}

type queryResolver struct{ *Resolver }

// Shipments handles the GraphQL query for fetching shipments.
// It calls the gRPC client with filters and pagination, preserving the original logic structure.
// Analogy: Waiter takes a customer order (e.g., "shipments from Dhaka") and sends it to the kitchen.
func (r *queryResolver) Shipments(ctx context.Context, origin *string, status *model.ShipmentStatus, destination *string, limit *int, offset *int) ([]*model.Shipment, error) {
	// Set default values for optional filters and pagination
	o, s, d := "", "", ""
	l, o2 := int32(10), int32(0) // Default limit=10, offset=0
	if origin != nil {
		o = *origin
	}
	if status != nil {
		s = string(*status) // Convert GraphQL enum (e.g., IN_TRANSIT) to string for gRPC
	}
	if destination != nil {
		d = *destination
	}
	if limit != nil {
		l = int32(*limit)
	}
	if offset != nil {
		o2 = int32(*offset)
	}

	// Call gRPC client to fetch shipments with filters and pagination
	// Analogy: Waiter sends the order (filters and pagination) to the kitchen via intercom
	shipments, err := r.shipmentClient.GetShipments(ctx, o, s, d, l, o2)
	if err != nil {
		return nil, err // Propagate errors (e.g., service unavailable)
	}

	// Convert gRPC response to GraphQL model
	result := make([]*model.Shipment, len(shipments))
	for i, s := range shipments {
		result[i] = &model.Shipment{
			ID:          s.ID,
			Origin:      s.Origin,
			Destination: s.Destination,
			Eta:         s.Eta,
			Status:      model.ShipmentStatus(s.Status), // Convert string to GraphQL enum
			Carrier: &model.Carrier{
				Name:        s.Carrier.Name,
				TrackingURL: s.Carrier.TrackingURL,
			},
		}
	}
	// Analogy: Waiter puts the kitchen's dishes on fancy plates for the customer
	return result, nil
}

// Health checks the status of the GraphQL Gateway.
// Analogy: Waiter confirms the dining room is open and can contact the kitchen.
func (r *queryResolver) Health(ctx context.Context) (string, error) {
	// Simple health check: verify gRPC connection is active
	_, err := r.shipmentClient.GetShipments(ctx, "", "", "", 1, 0)
	if err != nil {
		return "UNHEALTHY", fmt.Errorf("cannot reach shipment service: %v", err)
	}
	return "OK", nil
}

// //  In-memory store for shipments, initialized with hardcoded data
// // var shipments = []*model.Shipment{
// // 	{
// // 		ID:          "1",
// // 		Status:      model.ShipmentStatusInTransit, // Use enum value
// // 		Origin:      "Dhaka",
// // 		Destination: "Berlin",
// // 		Eta:         "2025-07-15",
// // 		Carrier: &model.Carrier{
// // 			Name:        "DHL",
// // 			TrackingURL: "https://dhl.com/track/123",
// // 		},
// // 	},
// // 	{
// // 		ID:          "2",
// // 		Status:      model.ShipmentStatusDelivered, // Use enum value
// // 		Origin:      "Chittagong",
// // 		Destination: "Munich",
// // 		Eta:         "2025-07-10",
// // 		Carrier: &model.Carrier{
// // 			Name:        "DHL",
// // 			TrackingURL: "https://dhl.com/track/123",
// // 		},
// // 	},
// // }

// // CreateShipment is the resolver for the createShipment field.
// func (r *mutationResolver) CreateShipment(ctx context.Context, input models.CreateShipmentInput) (*models.Shipment, error) {

// 	newShipment := models.Shipment{
// 		Status:      input.Status, // Uses GraphQL enum (IN_TRANSIT, DELIVERED, PENDING)
// 		Origin:      input.Origin,
// 		Destination: input.Destination,
// 		Eta:         input.Eta,
// 		Carrier: models.Carrier{
// 			Name:        input.Carrier.Name,
// 			TrackingURL: input.Carrier.TrackingURL, // Fixed to match schema (trackingUrl)
// 		},
// 	}
// 	// Call the gRPC client to create the shipment
// 	created, err := r.shipmentClient.CreateShipment(ctx, newShipment)
// 	if err != nil {
// 		return nil, err
// 	}
// 	// return  the created shipment...

// 	return &created, nil

// 	// shipments = append(shipments, newShipment)
// 	// return newShipment, nil
// }

// // Now implement Query resolver methods on queryResolver
// func (r *queryResolver) Shipments(ctx context.Context, origin *string, status *models.ShipmentStatus, destination *string, limit *int, offset *int) ([]*models.Shipment, error) {
// 	// Set default values for optional filters and pagination
// 	o, s, d := "", "", ""
// 	// Set default pagination values
// 	l, o2 := int32(10), int32(0)
// 	if origin != nil {
// 		o = *origin
// 	}
// 	if status != nil {
// 		s = string(*status) // Convert GraphQL enum to string for gRPC
// 	}
// 	if destination != nil {
// 		d = *destination
// 	}
// 	if limit != nil {
// 		l = int32(*limit)
// 	}
// 	if offset != nil {
// 		o2 = int32(*offset)
// 	}
// 	// Call gRPC client to fetch shipments
// 	shipments, err := r.shipmentClient.GetShipments(ctx, o, s, d, l, o2)
// 	if err != nil {
// 		return nil, err
// 	}
// 	// Convert to GraphQL model
// 	result := make([]*models.Shipment, len(shipments))
// 	for i, s := range shipments {
// 		result[i] = &models.Shipment{
// 			ID:          s.ID,
// 			Origin:      s.Origin,
// 			Destination: s.Destination,
// 			Eta:         s.Eta,
// 			Status:      models.ShipmentStatus(s.Status), // Convert string to enum
// 			Carrier: models.Carrier{
// 				Name:        s.Carrier.Name,
// 				TrackingURL: s.Carrier.TrackingURL,
// 			},
// 		}
// 	}
// 	return result, nil

// 	//start with all shipments..............
// 	// filtered := shipments

// 	// Apply all Filter  if  any parameter provided

// 	// if origin != nil || status != nil || destination != nil {
// 	// 	var temp []*model.Shipment
// 	// 	for _, shipment := range shipments {
// 	//check shipments matches all provided filters..
// 	// 		matches := true
// 	// 		if origin != nil && shipment.Origin != *origin {
// 	// 			matches = false

// 	// 		}
// 	// 		if status != nil && shipment.Status != *status {
// 	// 			matches = false
// 	// 		}
// 	// 		if destination != nil && shipment.Destination != *destination {
// 	// 			matches = false
// 	// 		}
// 	// Include shipment if it matches all filters
// 	// 		if matches {
// 	// 			temp = append(temp, shipment)
// 	// 		}
// 	// 	}

// 	// } else {

// 	// 	filtered = shipments // No filter, use all shipments
// 	// }

// 	//  Apply pagination
// 	// Ensure offset is valid (not negative or beyond the list length)
// 	// if off < 0 || off > len(filtered) {
// 	// 	return []*model.Shipment{}, nil //Return empty list for invalid offset
// 	// }
// 	// Ensure limit is non-negative
// 	// if lim < 0 {
// 	// 	lim = 0
// 	// }
// 	// Calculate the end index for slicing (offset + limit)
// 	// end := lim + off
// 	// if end > len(filtered) {
// 	// 	end = len(filtered) // Donâ€™t exceed the list length

// 	// }
// 	// Return the paginated slice (e.g., filtered[0:10] for first 10 items)
// 	// return filtered[off:end], nil
// }

// // Health checks the status of the GraphQL Gateway.
// // Analogy: Waiter confirms the dining room is open and can contact the kitchen.
// func (r *queryResolver) Health(ctx context.Context) (string, error) {
// 	// Simple health check: verify gRPC connection is active
// 	_, err := r.shipmentClient.GetShipments(ctx, "", "", "", 1, 0)
// 	if err != nil {
// 		return "UNHEALTHY", fmt.Errorf("cannot reach shipment service: %v", err)
// 	}
// 	return "OK", nil
// }

// // Mutation returns the MutationResolver implementation.
// // Analogy: Defines the waiter's tasks for handling customer orders (mutations).
// func (r *Resolver) Mutation() generated.MutationResolver {
// 	return &mutationResolver{r}
// }

// // Query returns Hilary returns the QueryResolver implementation.
// // Analogy: Defines the waiter's tasks for handling customer queries.
// func (r *Resolver) Query() generated.QueryResolver {
// 	return &queryResolver{r}
// }

// type mutationResolver struct{ *Resolver }
// type queryResolver struct{ *Resolver }
